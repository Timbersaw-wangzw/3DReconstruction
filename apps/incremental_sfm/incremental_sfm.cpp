#include <cstdlib>

#include "mvg/sfm/sfm_incremental_engine.h"

#include "mvg/utils/cmd_line.h"
#include "mvg/utils/file_system.h"
#include "mvg/utils/timer.h"

using namespace mvg::sfm;

int main(int argc, char **argv)
{
  std::cout << "Incremental reconstruction" << std::endl
            << " Perform incremental SfM (Initial Pair Essential + Resection)." << std::endl
            << std::endl;

  CmdLine cmd;

  std::string image_dir;
  std::string matches_dir;
  std::string out_dir = "";
  bool is_pmvs_export = false;
  bool is_refine_point_and_distortion = true;
  bool is_colored_point_cloud = false;
  std::pair<size_t,size_t> initial_pair(0,0);

  cmd.add( make_option('i', image_dir, "imadir") );
  cmd.add( make_option('m', matches_dir, "matchdir") );
  cmd.add( make_option('o', out_dir, "outdir") );
  cmd.add( make_option('p', is_pmvs_export, "pmvs") );
  cmd.add( make_option('a', initial_pair.first, "initialPairA") );
  cmd.add( make_option('b', initial_pair.second, "initialPairB") );
  cmd.add( make_option('c', is_colored_point_cloud, "coloredPointCloud") );
  cmd.add( make_option('d', is_refine_point_and_distortion, "refinePPandDisto") );


  try {
    if (argc == 1) throw std::string("Invalid command line parameter.");
    cmd.process(argc, argv);
  } catch(const std::string& s) {
    std::cerr << "Usage: " << argv[0] << '\n'
    << "[-i|--imadir path] \n"
    << "[-m|--matchdir path] \n"
    << "[-o|--outdir path] \n"
    << "[-p|--pmvs 0 or 1] \n"
    << "[-a|--initialPairA number] \n"
    << "[-b|--initialPairB number] \n"
    << "[-c|--coloredPointCloud 0(default) or 1]\n"
    << "[-d|--refinePPandDisto \n"
    << "\t 0-> refine only the Focal,\n"
    << "\t 1-> refine Focal, Principal point and radial distortion factors.] \n"
    << std::endl;

    std::cerr << s << std::endl;
    return EXIT_FAILURE;
  }

  if (out_dir.empty())  {
    std::cerr << "\nIt is an invalid output directory" << std::endl;
    return EXIT_FAILURE;
  }

  if (!mvg::utils::folder_exists(out_dir))
    mvg::utils::folder_create(out_dir);

  // 计时开始
  mvg::utils::Timer timer;
  timer.Start();

  mvg::sfm::IncrementalReconstructionEngine to_3d_engine(image_dir,
                                            matches_dir,
                                            out_dir,
                                            true);

  to_3d_engine.setInitialPair(initial_pair);
  to_3d_engine.setIfRefinePrincipalPointAndRadialDistortion(is_refine_point_and_distortion);

  if (to_3d_engine.Process())
  {
    std::cout << std::endl << " Ac-Sfm took (s): " << timer.Stop() << "." << std::endl;

    const ReconstructorHelper & reconstructor_helper_ref = to_3d_engine.refToReconstructorHelper();
    std::vector<Vec3> vec_tracks_color;
    if (is_colored_point_cloud)
    {
      // Compute the color of each track
      to_3d_engine.ColorizeTracks(vec_tracks_color);
    }
    reconstructor_helper_ref.exportToPlyFile(
      mvg::utils::create_filespec(out_dir, "FinalColorized", ".ply"),
      is_colored_point_cloud ? &vec_tracks_color : NULL);

    // Export to openMVG format
    std::cout << std::endl << "Export 3D scene to openMVG format" << std::endl
      << " -- Point cloud color: " << (is_colored_point_cloud ? "ON" : "OFF") << std::endl;

    reconstructor_helper_ref.ExportToOpenMVGFormat(
      mvg::utils::folder_append_separator(out_dir) + "SfM_output",
      to_3d_engine.getFilenamesVector(),
      image_dir,
      to_3d_engine.getImagesSize(),
      to_3d_engine.getTracks(),
      is_colored_point_cloud ? &vec_tracks_color : NULL,
      true,
      std::string("generated by the Sequential OpenMVG Calibration Engine")
      );

    // Manage export data to desired format
    // -> PMVS
    if (is_pmvs_export)  {
      std::cout << std::endl << "Export 3D scene to PMVS format" << std::endl;
      reconstructor_helper_ref.exportToPMVSFormat(
        mvg::utils::folder_append_separator(out_dir) + "PMVS",
        to_3d_engine.getFilenamesVector(),
        image_dir);
    }

    return EXIT_SUCCESS;
  }
  else
  {
    std::cerr << "\n Something goes wrong in the Structure from Motion process" << std::endl;
  }
  return EXIT_FAILURE;
}
